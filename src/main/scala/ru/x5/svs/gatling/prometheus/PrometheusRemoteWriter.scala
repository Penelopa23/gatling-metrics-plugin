package ru.x5.svs.gatling.prometheus

import org.slf4j.LoggerFactory
import java.util.concurrent.{ScheduledExecutorService, Executors, TimeUnit}
import scala.concurrent.ExecutionContext
import org.apache.hc.client5.http.impl.classic.HttpClients
import org.apache.hc.client5.http.config.RequestConfig
import org.apache.hc.core5.util.Timeout
import org.apache.hc.core5.http.io.entity.StringEntity
import org.apache.hc.client5.http.classic.methods.HttpPost
import org.apache.hc.core5.http.ContentType
// import ru.x5.svs.gatling.prometheus.infrastructure.ThreadSafeExecutorPool
// import ru.x5.svs.gatling.prometheus.monitoring.ThreadMonitor

/**
 * –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ô PrometheusRemoteWriter - –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –≤ Victoria Metrics
 */
class PrometheusRemoteWriter(
  private val victoriaMetricsUrl: String,
  private val testId: String,
  private val pod: String,
  private val pushIntervalSeconds: Int = 5
)(implicit private val ec: ExecutionContext) {

  private val logger = LoggerFactory.getLogger(classOf[PrometheusRemoteWriter])
  
  // –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
  sealed trait State
  case object RUNNING extends State
  case object FLUSHING extends State
  case object STOPPED extends State
  
  private val state = new java.util.concurrent.atomic.AtomicReference[State](RUNNING)
  private val finalized = new java.util.concurrent.atomic.AtomicBoolean(false)
  
  // –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –¥–ª—è –≤—ã—Å–æ–∫–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏
  private val scheduler: ScheduledExecutorService = Executors.newScheduledThreadPool(2)
  
  // HTTP –∫–ª–∏–µ–Ω—Ç —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏
  private val httpClient = HttpClients.custom()
    .setDefaultRequestConfig(RequestConfig.custom()
      .setConnectTimeout(Timeout.ofSeconds(3))
      .setResponseTimeout(Timeout.ofSeconds(5))
      .build())
    .build()
  
  // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è –±–∞—Ç—á–∏–Ω–≥–∞
  private val maxCharsPerBatch = 1_000_000  // ~1MB —Ç–µ–∫—Å—Ç–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ
  
  // THREAD-SAFE –ø—É–ª –ø–æ—Ç–æ–∫–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–µ—Ç—Ä–∏–∫ —Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º
  // private val metricsProcessor = new ThreadSafeExecutorPool(
  //   name = "PrometheusMetricsProcessor",
  //   corePoolSize = Math.max(2, Runtime.getRuntime.availableProcessors() / 2),
  //   maxPoolSize = Math.max(4, Runtime.getRuntime.availableProcessors()),
  //   queueCapacity = 1000
  // )
  
  /**
   * –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫—É—é –æ—Ç–ø—Ä–∞–≤–∫—É –º–µ—Ç—Ä–∏–∫
   */
  def start(): Unit = {
    if (state.get() == RUNNING) {
      logger.info(s"ORIGINAL PrometheusRemoteWriter: Starting periodic export to $victoriaMetricsUrl")
      
      // –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–æ—Ç–æ–∫–æ–≤
      // ThreadMonitor.startMonitoring()
      
      try {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä—É–µ–º—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ—Ç–ø—Ä–∞–≤–∫–∏ –º–µ—Ç—Ä–∏–∫
        val intervalSeconds = pushIntervalSeconds
        val scheduledFuture = scheduler.scheduleAtFixedRate(
          new Runnable {
            override def run(): Unit = {
              // –ê–°–ò–ù–•–†–û–ù–ù–ê–Ø –æ–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ—Ç—Ä–∏–∫
              try {
                logger.info(s"üî• ORIGINAL PrometheusRemoteWriter: SCHEDULER TRIGGERED! Thread: ${Thread.currentThread().getName}")
                sendMetrics()
                logger.info(s"üî• ORIGINAL PrometheusRemoteWriter: SCHEDULER COMPLETED successfully!")
              } catch {
                case e: Exception =>
                  logger.error(s"üî• ORIGINAL PrometheusRemoteWriter: SCHEDULER ERROR: ${e.getMessage}", e)
              }
            }
          },
          intervalSeconds, intervalSeconds, TimeUnit.SECONDS
        )
        
        logger.info(s"üî• ORIGINAL PrometheusRemoteWriter: Started periodic export - scheduled task: $scheduledFuture")
        logger.info(s"üî• ORIGINAL PrometheusRemoteWriter: Scheduler is running: ${!scheduler.isShutdown}")
        
      } catch {
        case e: Exception =>
          logger.error(s"ORIGINAL PrometheusRemoteWriter: ERROR starting scheduler: ${e.getMessage}", e)
          state.set(STOPPED)
      }
    } else {
      logger.warn(s"ORIGINAL PrometheusRemoteWriter: Not in RUNNING state, skipping start")
    }
  }
  
  /**
   * –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –º–µ—Ç—Ä–∏–∫
   */
  def stop(): Unit = {
    // –ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å - –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –¥–≤–æ–π–Ω–æ–π –≤—ã–∑–æ–≤
    if (!finalized.compareAndSet(false, true)) {
      logger.warn("ORIGINAL PrometheusRemoteWriter: Already finalized")
      return
    }
    
    state.get match {
      case STOPPED => 
        logger.warn("ORIGINAL PrometheusRemoteWriter: Already stopped")
        return
      case _ =>
    }
    
    logger.info("ORIGINAL PrometheusRemoteWriter: Stopping periodic export")
    
    // 1) –ë–æ–ª—å—à–µ –Ω–µ –ø–ª–∞–Ω–∏—Ä—É–µ–º –ù–û–í–´–ï –∑–∞–¥–∞—á–∏, –Ω–æ –¥–∞—ë–º –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è —Ç–µ–∫—É—â–∏–º
    scheduler.shutdown()
    try {
      if (!scheduler.awaitTermination(2, java.util.concurrent.TimeUnit.SECONDS)) {
        logger.warn("ORIGINAL PrometheusRemoteWriter: Scheduler did not terminate gracefully, forcing shutdown")
        scheduler.shutdownNow()
      }
    } catch {
      case e: InterruptedException =>
        logger.warn("ORIGINAL PrometheusRemoteWriter: Interrupted while waiting for scheduler termination")
        scheduler.shutdownNow()
        Thread.currentThread().interrupt()
    }
    
    // 2) –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ FLUSHING (enqueue() –µ—â—ë –º–æ–∂–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
    if (!state.compareAndSet(RUNNING, FLUSHING)) {
      logger.warn("ORIGINAL PrometheusRemoteWriter: Stop called not from RUNNING state")
    }
    
    // 3) –ë–õ–û–ö–ò–†–£–Æ–©–ò–ô —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–ª–∞—à —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏ –∏ –∫—É—Å–æ–≤–∞–Ω–∏–µ–º
    logger.info("ORIGINAL PrometheusRemoteWriter: Flushing final metrics")
    flushBlocking()
    
    // 4) –¢–µ–ø–µ—Ä—å —É–∂–µ STOPPED ‚Äì –¥–∞–ª—å—à–µ enqueue() –¥–æ–ª–∂–Ω–æ –æ—Ç–∫–∞–∑—ã–≤–∞—Ç—å
    state.set(STOPPED)
    logger.info("ORIGINAL PrometheusRemoteWriter: Stopped and sent final metrics")
  }
  
  /**
   * –ë–ª–æ–∫–∏—Ä—É—é—â–∏–π —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–ª–∞—à —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏ –∏ –∫—É—Å–æ–≤–∞–Ω–∏–µ–º
   */
  private def flushBlocking(): Unit = {
    val url = victoriaMetricsUrl.replace("/api/v1/write", "/api/v1/import/prometheus")
    var chunk = pullChunk(maxCharsPerBatch) // –¥–æ—Å—Ç–∞—ë—Ç —Å—Ç—Ä–æ–∫—É –∏–∑ –æ—á–µ—Ä–µ–¥–∏ –¥–æ –ª–∏–º–∏—Ç–∞
    while (chunk.nonEmpty) {
      sendChunk(url, chunk)
      chunk = pullChunk(maxCharsPerBatch)
    }
  }
  
  /**
   * –ò–∑–≤–ª–µ—á—å —á–∞–Ω–∫ –º–µ—Ç—Ä–∏–∫ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
   */
  private def pullChunk(maxChars: Int): String = {
    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –º–µ—Ç—Ä–∏–∫–∏ –∏–∑ PrometheusMetricsManager
    PrometheusMetricsManager.getInstance match {
      case Some(manager) =>
        val allMetrics = manager.createPrometheusFormat()
        if (allMetrics.length > maxChars) {
          allMetrics.take(maxChars)
        } else {
          allMetrics
        }
      case None => ""
    }
  }
  
  /**
   * –û—Ç–ø—Ä–∞–≤–∏—Ç—å —á–∞–Ω–∫ –º–µ—Ç—Ä–∏–∫ —Å —Ç–∞–π–º–∞—É—Ç–∞–º–∏ (–±–µ–∑ gzip –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
   */
  private def sendChunk(url: String, data: String): Unit = {
    if (data.isEmpty) return
    
    try {
      val req = new HttpPost(url)
      val entity = new StringEntity(data, ContentType.TEXT_PLAIN)
      req.setEntity(entity)
      req.setHeader("Content-Type", "text/plain")

      val resp = httpClient.execute(req)
      val code = resp.getCode
      val body = Option(resp.getEntity).map(e => new String(e.getContent.readAllBytes(), "UTF-8")).getOrElse("")
      
      if (code != 204) {
        logger.error(s"VM import failed: $code body=${body.take(200)}")
      } else {
        logger.info(s"Successfully sent chunk of ${data.length} characters to Victoria Metrics")
      }
      
    } catch {
      case e: Exception =>
        logger.error(s"Error sending chunk to Victoria Metrics: ${e.getMessage}", e)
    }
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–∏—Ç—å –º–µ—Ç—Ä–∏–∫–∏ –≤ Victoria Metrics –∏–∑ –æ—á–µ—Ä–µ–¥–∏
   */
  private def sendMetrics(): Unit = {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ writer –µ—â–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
    if (state.get() == STOPPED) {
      logger.warn("QUEUE: Writer is stopped, skipping metrics sending")
      return
    }
    
    try {
      logger.info(s"üìä QUEUE: Starting batch metrics sending from queue")
      
      // –ù–ï –ò–°–ü–û–õ–¨–ó–£–ï–ú –æ—á–µ—Ä–µ–¥—å! –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏!
      val queueStats = MetricsQueue.getQueueStats()
      
      logger.info(s"üìä QUEUE: Queue stats: $queueStats")
      
      // –í—Å–µ–≥–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ (–Ω–µ –∑–∞–≤–∏—Å–∏–º –æ—Ç –æ—á–µ—Ä–µ–¥–∏)
      if (queueStats.httpRequestCount > 0 || queueStats.httpErrorCount > 0) {
        val managerOpt = PrometheusMetricsManager.getInstance
        
        managerOpt.foreach { manager =>
          logger.info(s"üìä QUEUE: Processing metrics with manager...")
          
          // –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
          val httpRequestCounters = MetricsQueue.getHttpRequestCounters()
          val httpErrorCounters = MetricsQueue.getHttpErrorCounters()
          val httpDurations = MetricsQueue.getHttpDurations()
          
          // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –≤ PrometheusMetricsManager
          manager.updateHttpMetricsFromQueue(httpRequestCounters, httpErrorCounters)
          
          // –û–±–Ω–æ–≤–ª—è–µ–º HTTP durations
          manager.updateHttpDurationsFromQueue(httpDurations)
          
          // –õ–æ–≥–∏—Ä—É–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
          manager.logSystemMetrics()
          
          // –°–æ–∑–¥–∞–µ–º Prometheus —Ñ–æ—Ä–º–∞—Ç —Å–æ –≤—Å–µ–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏
          val allMetrics = manager.createPrometheusFormat()
          logger.info(s"üìä QUEUE: Created Prometheus format (${allMetrics.length} chars)")
          
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Victoria Metrics
          manager.sendToVictoriaMetrics(allMetrics)
          logger.info(s"üìä QUEUE: Successfully sent batch metrics to Victoria Metrics!")
          
          // –ù–ï –û–ß–ò–©–ê–ï–ú –æ—á–µ—Ä–µ–¥—å! –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏!
          // MetricsQueue.clearQueue() // –£–ë–†–ê–ù–û - –Ω–µ –æ—á–∏—â–∞–µ–º –æ—á–µ—Ä–µ–¥—å!
        }
      } else {
        logger.info(s"üìä QUEUE: No metrics in queue, skipping batch send")
      }
      
    } catch {
      case e: Exception =>
        logger.error(s"üìä QUEUE: Error sending batch metrics: ${e.getMessage}", e)
    }
  }
  
}

object PrometheusRemoteWriter {
  private var instance: Option[PrometheusRemoteWriter] = None
  
  def initialize(victoriaMetricsUrl: String, testId: String, pod: String)(implicit ec: ExecutionContext): PrometheusRemoteWriter = {
    instance = Some(new PrometheusRemoteWriter(victoriaMetricsUrl, testId, pod))
    instance.get
  }
  
  def getInstance: Option[PrometheusRemoteWriter] = instance
  
  def start(): Unit = {
    instance.foreach(_.start())
  }
  
  def stop(): Unit = {
    instance.foreach(_.stop())
  }
}
