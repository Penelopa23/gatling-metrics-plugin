package ru.x5.svs.gatling.prometheus

import org.slf4j.LoggerFactory
import java.util.concurrent.{ConcurrentHashMap, ScheduledExecutorService, Executors, TimeUnit}
import java.util.concurrent.atomic.AtomicBoolean
import scala.collection.mutable
import scala.concurrent.{ExecutionContext, Future}
import scala.concurrent.duration._

/**
 * –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ô PrometheusMetricsManager - —Ä–∞–±–æ—á–∞—è —Å–∏—Å—Ç–µ–º–∞ –º–µ—Ç—Ä–∏–∫
 * –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –≤ Victoria Metrics –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ —Ç–µ—Å—Ç–∞
 */
class PrometheusMetricsManager(
  private val victoriaMetricsUrl: String,
  private val testId: String,
  private val pod: String
)(implicit private val ec: ExecutionContext) {

  private val logger = LoggerFactory.getLogger(classOf[PrometheusMetricsManager])
  
  // –•—Ä–∞–Ω–∏–ª–∏—â–µ –º–µ—Ç—Ä–∏–∫ —Å thread-safe –∫–æ–ª–ª–µ–∫—Ü–∏—è–º–∏
  private val httpErrors = new ConcurrentHashMap[String, Int]()
  private val httpRequests = new ConcurrentHashMap[String, Int]()
  private val httpDurations = new ConcurrentHashMap[String, java.util.concurrent.CopyOnWriteArrayList[Long]]()
  private val virtualUsers = new java.util.concurrent.atomic.AtomicInteger(0)  // –ò–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ AtomicInteger –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ VU
  
  // –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏—Ç–µ—Ä–∞—Ü–∏–π —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ —Å thread-safe –∫–æ–ª–ª–µ–∫—Ü–∏—è–º–∏
  private val iterationDurations = new ConcurrentHashMap[String, java.util.concurrent.CopyOnWriteArrayList[Long]]()
  
  // –§–ª–∞–≥ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –º–µ—Ç—Ä–∏–∫ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
  private val metricsSent = new AtomicBoolean(false)
  
  /**
   * –ü–æ–ª—É—á–∏—Ç—å testId
   */
  def getTestId: String = testId
  
  /**
   * –ü–æ–ª—É—á–∏—Ç—å pod
   */
  def getPod: String = pod
  
  /**
   * –°–æ–±—Ä–∞—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ (–ø–∞–º—è—Ç—å, GC)
   * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç Map[metricName, value]
   */
  def collectSystemMetrics(): Map[String, Double] = {
    import java.lang.management.ManagementFactory
    import scala.jdk.CollectionConverters._
    
    val runtime = Runtime.getRuntime
    val totalMemory = runtime.totalMemory()
    val freeMemory = runtime.freeMemory()
    val usedMemory = totalMemory - freeMemory
    val maxMemory = runtime.maxMemory()
    
    // Get GC metrics
    val memoryMXBean = ManagementFactory.getMemoryMXBean
    val heapMemoryUsage = memoryMXBean.getHeapMemoryUsage
    val nonHeapMemoryUsage = memoryMXBean.getNonHeapMemoryUsage
    
    // Get GC MXBean for GC statistics
    val gcMXBeans = ManagementFactory.getGarbageCollectorMXBeans
    val totalGcTime = gcMXBeans.asScala.map(_.getCollectionTime).sum
    val totalGcCount = gcMXBeans.asScala.map(_.getCollectionCount).sum
    
    // Get memory pool MXBeans for stack metrics
    val memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans
    val stackInuse = memoryPoolMXBeans.asScala
      .filter(pool => pool.getName.contains("Code Cache") || pool.getName.contains("Metaspace"))
      .map(_.getUsage.getUsed)
      .sum
    
    Map(
      "gatling_memory_alloc_bytes" -> usedMemory.toDouble,
      "gatling_memory_heap_alloc_bytes" -> heapMemoryUsage.getUsed.toDouble,
      "gatling_memory_heap_sys_bytes" -> heapMemoryUsage.getCommitted.toDouble,
      "gatling_memory_heap_idle_bytes" -> (heapMemoryUsage.getCommitted - heapMemoryUsage.getUsed).toDouble,
      "gatling_memory_heap_inuse_bytes" -> heapMemoryUsage.getUsed.toDouble,
      "gatling_memory_stack_inuse_bytes" -> stackInuse.toDouble,
      "gatling_memory_stack_sys_bytes" -> nonHeapMemoryUsage.getCommitted.toDouble,
      "gatling_gc_count" -> totalGcCount.toDouble,
      "gatling_gc_pause_ms" -> totalGcTime.toDouble  // –í –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
    )
  }
  
  /**
   * –ó–∞–ø–∏—Å–∞—Ç—å HTTP –æ—à–∏–±–∫—É - –° –î–ï–¢–ê–õ–¨–ù–´–ú–ò –°–û–û–ë–©–ï–ù–ò–Ø–ú–ò!
   */
  def recordHttpError(scenario: String, request: String, method: String, status: String, errorMessage: String): Unit = {
    val key = s"$scenario|$request|$method|$status|$errorMessage"
    httpErrors.compute(key, (_, count) => if (count == null) 1 else count + 1)
    logger.warn(s"HTTP_ERROR: $key error=$errorMessage")
  }
  
  /**
   * –ó–∞–ø–∏—Å–∞—Ç—å HTTP –∑–∞–ø—Ä–æ—Å
   */
  def recordHttpRequest(scenario: String, request: String, method: String, status: String): Unit = {
    val key = s"$scenario|$request|$method|$status"
    httpRequests.compute(key, (_, count) => if (count == null) 1 else count + 1)
    logger.debug(s"HTTP_REQUEST: $key")
  }
  
  /**
   * –ó–∞–ø–∏—Å–∞—Ç—å HTTP –∑–∞–ø—Ä–æ—Å —Å —Å–æ–æ–±—â–µ–Ω–∏–µ–º –æ–± –æ—à–∏–±–∫–µ (–ë–ï–ó errorMessage –≤ –∫–ª—é—á–µ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è)
   */
  def recordHttpRequest(scenario: String, request: String, method: String, status: String, _errorMessage: String): Unit = {
    val key = s"$scenario|$request|$method|$status"
    httpRequests.compute(key, (_, count) => if (count == null) 1 else count + 1)
    logger.debug(s"HTTP_REQUEST: $key")
  }
  
  /**
   * –ó–∞–ø–∏—Å–∞—Ç—å HTTP –∑–∞–ø—Ä–æ—Å —Å duration (–≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞)
   */
  def recordHttpRequestWithDuration(scenario: String, request: String, method: String, status: String, responseTime: Long): Unit = {
    val key = s"$scenario|$request|$method|$status"
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º count
    httpRequests.compute(key, (_, count) => if (count == null) 1 else count + 1)
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º duration
    httpDurations.compute(key, (_, durations) => {
      val list = if (durations == null) new java.util.concurrent.CopyOnWriteArrayList[Long]() else durations
      list.add(responseTime)
      list
    })
    
    logger.info(s"üî• ORIGINAL: Recorded HTTP request with duration: $key, responseTime=${responseTime}ms")
  }
  
  /**
   * –û–±–Ω–æ–≤–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ DataWriter)
   */
  def updateVirtualUsersCount(count: Int): Unit = {
    virtualUsers.set(count)
    logger.info(s"üìä VU COUNT UPDATED: $count active virtual users")
  }
  
  /**
   * –û–±–Ω–æ–≤–∏—Ç—å –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—å–Ω—ã–µ HTTP –º–µ—Ç—Ä–∏–∫–∏ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
   */
  def updateHttpMetricsFromQueue(requestCounters: Map[String, Long], errorCounters: Map[String, Long]): Unit = {
    try {
      // –ó–ê–ú–ï–ù–Ø–ï–ú —Å—á–µ—Ç—á–∏–∫–∏ HTTP –∑–∞–ø—Ä–æ—Å–æ–≤ (–ù–ï –î–û–ë–ê–í–õ–Ø–ï–ú!)
      requestCounters.foreach { case (key, count) =>
        httpRequests.put(key, count.toInt)
      }
      
      // –ó–ê–ú–ï–ù–Ø–ï–ú —Å—á–µ—Ç—á–∏–∫–∏ HTTP –æ—à–∏–±–æ–∫ (–ù–ï –î–û–ë–ê–í–õ–Ø–ï–ú!)
      errorCounters.foreach { case (key, count) =>
        httpErrors.put(key, count.toInt)
      }
      
      logger.info(s"üìä QUEUE: Updated HTTP metrics - requests: ${requestCounters.size}, errors: ${errorCounters.size}")
    } catch {
      case e: Exception =>
        logger.error(s"üìä QUEUE: Error updating HTTP metrics from queue: ${e.getMessage}", e)
    }
  }
  
  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
   */
  def getCurrentVirtualUsersCount(): Int = {
    virtualUsers.get()
  }
  
  /**
   * –ü–æ–ª—É—á–∏—Ç—å –ø–∏–∫–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
   */
  def getPeakVirtualUsersCount(): Int = {
    // –ü–æ–ª—É—á–∞–µ–º –ø–∏–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ MetricsQueue
    MetricsQueue.getPeakVirtualUsersCount()
  }
  
  /**
   * –ó–∞–ø–∏—Å–∞—Ç—å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏–∏ —Å—Ü–µ–Ω–∞—Ä–∏—è
   */
  def recordIterationDuration(scenario: String, duration: Long): Unit = {
    iterationDurations.compute(scenario, (_, durations) => {
      val list = if (durations == null) new java.util.concurrent.CopyOnWriteArrayList[Long]() else durations
      list.add(duration)
      list
    })
    logger.info(s"üî• ORIGINAL: Recorded iteration duration: scenario=$scenario, duration=${duration}ms")
  }
  
  /**
   * –í—Å–µ–≥–¥–∞ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏ –ª–æ–≥–∏—Ä–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ (–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–∫ –æ—Ç–ø—Ä–∞–≤–∫–∏)
   */
  def logSystemMetrics(): Unit = {
    val systemMetrics = collectSystemMetrics()
    systemMetrics.foreach { case (metricName, value) =>
      val labels = s"""testid="$testId",pod="$pod""""
      val metricLine = s"$metricName{$labels} $value"
      logger.error(s"üìä SYSTEM METRIC: $metricLine")
    }
    
    // –õ–æ–≥–∏—Ä—É–µ–º –º–µ—Ç—Ä–∏–∫–∏ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (—Ç–µ–∫—É—â–µ–µ –∏ –ø–∏–∫–æ–≤–æ–µ)
    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ß–∏—Ç–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ MetricsQueue –≤–º–µ—Å—Ç–æ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—è
    val vuValue = MetricsQueue.getVirtualUsersCount()
    val vuLabels = s"""testid="$testId",pod="$pod""""
    val vuMetricLine = s"gatling_vus{$vuLabels} $vuValue"
    logger.error(s"üìä VU METRIC: $vuMetricLine")
    
    // –õ–æ–≥–∏—Ä—É–µ–º –ø–∏–∫–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ VU
    val peakVuValue = getPeakVirtualUsersCount()
    logger.error(s"üìä VU PEAK DEBUG: peakVuValue=$peakVuValue, currentVuValue=$vuValue")
    val peakVuMetricLine = s"gatling_vus_peak{$vuLabels} $peakVuValue"
    logger.error(s"üìä VU PEAK METRIC: $peakVuMetricLine")
  }
  
  /**
   * –û—Ç–ø—Ä–∞–≤–∏—Ç—å –í–°–ï –º–µ—Ç—Ä–∏–∫–∏ –≤ Victoria Metrics –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ —Ç–µ—Å—Ç–∞
   */
  def sendMetricsOnTestStop(): Unit = {
    logger.error("üö®üö®üö® PrometheusMetricsManager.sendMetricsOnTestStop() CALLED!")
    
    if (metricsSent.compareAndSet(false, true)) {
      logger.error(s"üî• ORIGINAL: Sending ALL metrics to Victoria Metrics on test stop!")
      
      try {
        val allMetrics = createPrometheusFormat()
        logger.error(s"üî• ORIGINAL: Created Prometheus format (${allMetrics.length} chars)")
        logger.error(s"üî• ORIGINAL: First 500 chars:\n${allMetrics.take(500)}")
        
        sendToVictoriaMetrics(allMetrics)
        logger.error(s"üî• ORIGINAL: Successfully sent metrics to Victoria Metrics!")
        
      } catch {
        case e: Exception =>
          logger.error(s"üî• ORIGINAL: Error sending metrics: ${e.getMessage}", e)
      }
    } else {
      logger.error(s"üî• ORIGINAL: Metrics already sent, skipping sendMetricsOnTestStop")
    }
  }
  
  /**
   * –í–´–í–û–î –í–°–ï–• –ó–ê–†–ï–ì–ò–°–¢–†–ò–†–û–í–ê–ù–ù–´–• –ú–ï–¢–†–ò–ö –í –ö–û–ù–°–û–õ–¨ –ü–†–ò –°–¢–ê–†–¢–ï!
   */
  def printAllRegisteredMetrics(): Unit = {
    logger.info(s"üî• ORIGINAL: ===== –í–°–ï –ó–ê–†–ï–ì–ò–°–¢–†–ò–†–û–í–ê–ù–ù–´–ï –ú–ï–¢–†–ò–ö–ò =====")
    logger.info(s"üî• ORIGINAL: Test ID: $testId")
    logger.info(s"üî• ORIGINAL: Pod: $pod")
    logger.info(s"üî• ORIGINAL: Victoria Metrics URL: $victoriaMetricsUrl")
    
    logger.info(s"üî• ORIGINAL: ===== HTTP –û–®–ò–ë–ö–ò =====")
    if (httpErrors.isEmpty) {
      logger.info(s"üî• ORIGINAL: HTTP –æ—à–∏–±–æ–∫ –ø–æ–∫–∞ –Ω–µ—Ç")
    } else {
      httpErrors.forEach { (key, count) =>
        val parts = key.split("\\|")
        if (parts.length >= 5) {
          val scenario = parts(0)
          val request = parts(1)
          val method = parts(2)
          val status = parts(3)
          val errorMessage = parts(4)
          logger.info(s"üî• ORIGINAL: HTTP ERROR: scenario=$scenario, request=$request, method=$method, status=$status, error=$errorMessage, count=$count")
        }
      }
    }
    
    logger.info(s"üî• ORIGINAL: ===== HTTP –ó–ê–ü–†–û–°–´ =====")
    if (httpRequests.isEmpty) {
      logger.info(s"üî• ORIGINAL: HTTP –∑–∞–ø—Ä–æ—Å–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç")
    } else {
      httpRequests.forEach { (key, count) =>
        val parts = key.split("\\|")
        if (parts.length >= 4) {
          val scenario = parts(0)
          val request = parts(1)
          val method = parts(2)
          val status = parts(3)
          logger.info(s"üî• ORIGINAL: HTTP REQUEST: scenario=$scenario, request=$request, method=$method, status=$status, count=$count")
        }
      }
    }
    
    logger.info(s"üî• ORIGINAL: ===== –í–ò–†–¢–£–ê–õ–¨–ù–´–ï –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ò =====")
    logger.info(s"üî• ORIGINAL: Active VUs: ${virtualUsers.get()}")
    
    logger.info(s"üî• ORIGINAL: ===== –ö–û–ù–ï–¶ –ú–ï–¢–†–ò–ö =====")
  }
  
  /**
   * –°–æ–∑–¥–∞—Ç—å Prometheus —Ñ–æ—Ä–º–∞—Ç –∏–∑ –≤—Å–µ—Ö –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫
   */
  def createPrometheusFormat(): String = {
    val timestamp = System.currentTimeMillis() / 1000
    val lines = mutable.ListBuffer[String]()
    
    // HELP –∏ TYPE –∑–∞–≥–æ–ª–æ–≤–∫–∏ - k6/Penelopa —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è!
    lines += "# HELP gatling_http_req_failed Total number of failed HTTP requests"
    lines += "# TYPE gatling_http_req_failed counter"
    lines += "# HELP gatling_http_reqs_total Total number of HTTP requests"
    lines += "# TYPE gatling_http_reqs_total counter"
    lines += "# HELP gatling_http_req_duration HTTP request duration in milliseconds"
    lines += "# TYPE gatling_http_req_duration summary"
    lines += "# HELP gatling_vus Current number of virtual users"
    lines += "# TYPE gatling_vus gauge"
    lines += "# HELP gatling_vus_peak Peak number of virtual users during test"
    lines += "# TYPE gatling_vus_peak gauge"
    
    // HTTP –æ—à–∏–±–∫–∏ (failed requests) - –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–æ –≤ k6-compatible —Ñ–æ—Ä–º–∞—Ç
    httpErrors.forEach { (key, count) =>
      val parts = key.split("\\|")
      if (parts.length >= 5) {
        val scenario = parts(0)
        val request = parts(1)
        val method = parts(2)
        val status = parts(3)
        val errorMessage = parts(4)
        
        val labels = s"""testid="$testId",pod="$pod",scenario="$scenario",name="$request",method="$method",status="$status",error_message="$errorMessage""""
        val metricLine = s"gatling_http_req_failed{$labels} $count $timestamp"
        lines += metricLine
        logger.error(s"üìä METRIC: $metricLine")
      }
    }
    
    // HTTP –∑–∞–ø—Ä–æ—Å—ã
    httpRequests.forEach { (key, count) =>
      val parts = key.split("\\|")
      if (parts.length >= 4) {
        val scenario = parts(0)
        val request = parts(1)
        val method = parts(2)
        val status = parts(3)
        
        val labels = s"""testid="$testId",pod="$pod",scenario="$scenario",name="$request",method="$method",status="$status""""
        val metricLine = s"gatling_http_reqs_total{$labels} $count $timestamp"
        lines += metricLine
        logger.error(s"üìä METRIC: $metricLine")
      }
    }
    
    // HTTP request duration (summary metric)
    httpDurations.forEach { (key, durations) =>
      val parts = key.split("\\|")
      if (parts.length >= 4 && durations != null && !durations.isEmpty) {
        val scenario = parts(0)
        val request = parts(1)
        val method = parts(2)
        val status = parts(3)
        
        val labels = s"""testid="$testId",pod="$pod",scenario="$scenario",name="$request",method="$method",status="$status""""
        
        // –í—ã—á–∏—Å–ª—è–µ–º —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        import scala.jdk.CollectionConverters._
        val durationsList = durations.asScala.map(_.toLong).toList
        val avg = if (durationsList.nonEmpty) durationsList.sum / durationsList.size else 0
        
        // –ü—Ä–æ—Å—Ç–∞—è –º–µ—Ç—Ä–∏–∫–∞ –±–µ–∑ –∫–≤–∞–Ω—Ç–∏–ª–µ–π
        val metric_avg = s"gatling_http_req_duration{$labels} $avg $timestamp"
        
        lines += metric_avg
        
        logger.error(s"üìä DURATION METRIC: $metric_avg")
      }
    }
    
    // –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ - —Ç–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ß–∏—Ç–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ MetricsQueue –≤–º–µ—Å—Ç–æ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—è
    val vuValue = MetricsQueue.getVirtualUsersCount()
    val vuLabels = s"""testid="$testId",pod="$pod""""
    val metricVus = s"gatling_vus{$vuLabels} $vuValue $timestamp"
    lines += metricVus
    logger.error(s"üìä METRIC: $metricVus")
    
    // –ü–∏–∫–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    val peakVuValue = getPeakVirtualUsersCount()
    logger.error(s"üìä VU PEAK DEBUG: peakVuValue=$peakVuValue, currentVuValue=$vuValue")
    val metricVusPeak = s"gatling_vus_peak{$vuLabels} $peakVuValue $timestamp"
    lines += metricVusPeak
    logger.error(s"üìä METRIC: $metricVusPeak")
    
    // –°–ò–°–¢–ï–ú–ù–´–ï –ú–ï–¢–†–ò–ö–ò (–ø–∞–º—è—Ç—å, GC)
    lines += "# HELP gatling_memory_alloc_bytes Total allocated memory in bytes"
    lines += "# TYPE gatling_memory_alloc_bytes gauge"
    lines += "# HELP gatling_memory_heap_alloc_bytes Heap allocated memory in bytes"
    lines += "# TYPE gatling_memory_heap_alloc_bytes gauge"
    lines += "# HELP gatling_memory_heap_sys_bytes Heap system memory in bytes"
    lines += "# TYPE gatling_memory_heap_sys_bytes gauge"
    lines += "# HELP gatling_gc_count Total number of GC collections"
    lines += "# TYPE gatling_gc_count counter"
    lines += "# HELP gatling_gc_pause_ms Total GC pause time in milliseconds"
    lines += "# TYPE gatling_gc_pause_ms counter"
    
    // –ò–¢–ï–†–ê–¶–ò–ò –°–¶–ï–ù–ê–†–ò–ï–í (–¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–ª–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤)
    lines += "# HELP gatling_iteration_duration Iteration duration in milliseconds"
    lines += "# TYPE gatling_iteration_duration gauge"
    
    iterationDurations.forEach { (scenario, durations) =>
      if (durations != null && !durations.isEmpty) {
        import scala.jdk.CollectionConverters._
        val durationsList = durations.asScala.map(_.toLong).toList.sorted
        
        // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (—Ç–µ–∫—É—â–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏–∏)
        val currentDuration = durationsList.last
        
        val labels = s"""testid="$testId",pod="$pod",scenario="$scenario""""
        val metricLine = s"gatling_iteration_duration{$labels} $currentDuration $timestamp"
        lines += metricLine
        logger.error(s"üìä ITERATION METRIC: $metricLine")
      }
    }
    
    val systemMetrics = collectSystemMetrics()
    systemMetrics.foreach { case (metricName, value) =>
      val labels = s"""testid="$testId",pod="$pod""""
      val metricLine = s"$metricName{$labels} $value $timestamp"
      lines += metricLine
      logger.error(s"üìä SYSTEM METRIC: $metricLine")
    }
    
    logger.error(s"üìä TOTAL METRICS GENERATED: ${lines.size} lines")
    lines.mkString("\n")
  }
  
  /**
   * –û—Ç–ø—Ä–∞–≤–∏—Ç—å –º–µ—Ç—Ä–∏–∫–∏ –≤ Victoria Metrics —á–µ—Ä–µ–∑ Remote Write API (Protobuf + Snappy)
   * FALLBACK: –ï—Å–ª–∏ Protobuf –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–±—É–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç
   */
  def sendToVictoriaMetrics(metricsData: String): Unit = {
    import org.apache.hc.client5.http.classic.methods.HttpPost
    import org.apache.hc.client5.http.impl.classic.{HttpClients, CloseableHttpClient, CloseableHttpResponse}
    import org.apache.hc.core5.http.ContentType
    import org.apache.hc.core5.http.io.entity.{ByteArrayEntity, StringEntity}
    
    // –°–ù–ê–ß–ê–õ–ê –ü–†–û–ë–£–ï–ú –¢–ï–ö–°–¢–û–í–´–ô –§–û–†–ú–ê–¢ (–ø—Ä–æ—â–µ –∏ –Ω–∞–¥–µ–∂–Ω–µ–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
    try {
      val textFormatUrl = victoriaMetricsUrl.replace("/api/v1/write", "/api/v1/import/prometheus")
      logger.error(s"üî• VICTORIA METRICS TEXT FORMAT: Sending metrics to $textFormatUrl")
      logger.error(s"üî• VICTORIA METRICS TEXT FORMAT: Metrics data:\n${metricsData.take(1000)}")
      
      // –ü–†–û–í–ï–†–Ø–ï–ú: –µ—Å–ª–∏ URL –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å file://, –∑–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ —Ñ–∞–π–ª
      if (textFormatUrl.startsWith("file://")) {
        val filePath = textFormatUrl.substring(7) // —É–±–∏—Ä–∞–µ–º "file://"
        val file = new java.io.File(filePath)
        val writer = new java.io.FileWriter(file, false) // OVERWRITE mode - –Ω–µ –¥—É–±–ª–∏—Ä—É–µ–º!
        try {
          writer.write(metricsData)
          logger.error(s"‚úÖ Successfully wrote ${metricsData.length} characters to file: $filePath")
        } finally {
          writer.close()
        }
        return
      }
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º try-with-resources –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤
      val httpClient: CloseableHttpClient = HttpClients.createDefault()
      try {
        val request = new HttpPost(textFormatUrl)
        request.setEntity(new StringEntity(metricsData, ContentType.TEXT_PLAIN))
        request.setHeader("Content-Type", "text/plain")
        
        logger.error(s"üî• VICTORIA METRICS TEXT FORMAT: Sending ${metricsData.length} characters")
        
        val response: CloseableHttpResponse = httpClient.execute(request)
        
        val statusCode = response.getCode
        
        val responseBody = try {
          val entity = response.getEntity
          if (entity != null) {
            val content = new String(entity.getContent.readAllBytes(), "UTF-8")
            if (content.nonEmpty) content else "empty"
          } else {
            "no entity"
          }
        } catch {
          case e: Exception => s"error reading response: ${e.getMessage}"
        }
        
        logger.error(s"üî• VICTORIA METRICS TEXT FORMAT: HTTP Response Status: $statusCode")
        logger.error(s"üî• VICTORIA METRICS TEXT FORMAT: HTTP Response Body: $responseBody")
        
        if (statusCode >= 200 && statusCode < 300) {
          logger.error(s"‚úÖ Successfully sent metrics to Victoria Metrics in TEXT format (HTTP $statusCode)")
        } else {
          logger.error(s"‚ùå Failed to send metrics in TEXT format (HTTP $statusCode)")
          logger.error(s"‚ùå Response: $responseBody")
        }
        
        response.close()
        httpClient.close()
      }
    } catch {
      case e: Exception =>
        logger.error(s"üí• Error sending metrics in TEXT format to Victoria Metrics: ${e.getClass.getSimpleName}: ${e.getMessage}", e)
        // –ü–µ—Ä–µ–±—Ä–∞—Å—ã–≤–∞–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –∑–Ω–∞–ª –æ–± –æ—à–∏–±–∫–µ
        throw e
    }
  }
  
  /**
   * –û–±–Ω–æ–≤–∏—Ç—å HTTP durations –∏–∑ –æ—á–µ—Ä–µ–¥–∏ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ PrometheusRemoteWriter)
   */
  def updateHttpDurationsFromQueue(httpDurations: Map[String, Seq[Long]]): Unit = {
    // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ durations
    this.httpDurations.clear()
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ durations
    httpDurations.foreach { case (key, durations) =>
      val durationsList = new java.util.concurrent.CopyOnWriteArrayList[Long]()
      durations.foreach(durationsList.add)
      this.httpDurations.put(key, durationsList)
    }
    
    logger.info(s"üìä QUEUE: Updated HTTP durations from queue - ${httpDurations.size} duration groups")
  }
}

object PrometheusMetricsManager {
  private var instance: Option[PrometheusMetricsManager] = None
  
  def initialize(victoriaMetricsUrl: String, testId: String, pod: String)(implicit ec: ExecutionContext): PrometheusMetricsManager = {
    instance = Some(new PrometheusMetricsManager(victoriaMetricsUrl, testId, pod))
    instance.get
  }
  
  def getInstance: Option[PrometheusMetricsManager] = instance
  
  def sendMetricsOnTestStop(): Unit = {
    instance.foreach(_.sendMetricsOnTestStop())
  }
}
